<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:ns2="http://www.w3.org/1999/xlink">
    <key id="d0" for="node" attr.name="label" attr.type="string"/>
    <key id="d2" for="node" attr.name="color" attr.type="string"/>
    <graph edgedefault="directed">
        <desc></desc>
        <node id="REQ_WRAP_FUNCTIONS_EXCEPTIONS_INFO">
            <desc>All the functions must be wrapped by macros that report the exception info</desc>
            <data key="d0">REQ_WRAP_FUNCTIONS_EXCEPTIONS_INFO
All the functions must be wrapped by macros that report the exception info</data>
            <data key="d1">All the functions must be wrapped by special macros that capture
            the information about the exception being thrown or that cause a stack unwind.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_VARIABLE_MAX_IMAGE_SIZE">
            <desc>The settings of the maximum image size must be settable at runtime</desc>
            <data key="d0">REQ_VARIABLE_MAX_IMAGE_SIZE
The settings of the maximum image size must be settable at runtime</data>
            <data key="d1">The client application must be able to modify the maximum acceptable image size.
                The max image size settings must be clearly explained in the documentation.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_VR_CONVERSION">
            <desc>The library must be able to convert data between different VRs</desc>
            <data key="d0">REQ_VR_CONVERSION
The library must be able to convert data between different VRs</data>
            <data key="d1">The library must be able to convert data between different VRs, for instance
                from integer to double or string.
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_LOGGING">
            <desc>The library must log the most important tasks execution</desc>
            <data key="d0">REQ_LOGGING
The library must log the most important tasks execution</data>
            <data key="d1">The library must log to the device standard logging the most important steps.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_INSERT_FILES_IN_TAGS">
            <desc>Allow to insert reference to files into DICOM tags</desc>
            <data key="d0">REQ_INSERT_FILES_IN_TAGS
Allow to insert reference to files into DICOM tags</data>
            <data key="d1">The API client should be able to specify a file as content of a DICOM tag: when the DICOM stream is encoded then
      	           the specific tag content should be fetched directly from the file.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_DELAYED_LOAD">
            <desc>The library must be able to delay the loading of large chunk of data from the DICOM file</desc>
            <data key="d0">REQ_DELAYED_LOAD
The library must be able to delay the loading of large chunk of data from the DICOM file</data>
            <data key="d1">In order to minimize the memory footprint of the loaded datasets, the library must be able to load
                the tags data only when necessary.
                
                It should also release the loaded memory when the data is no longer necessary
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_PARSE_DICOMDIR">
            <desc>The library must be able to parse DICOMDIR structures and the records they contain</desc>
            <data key="d0">REQ_PARSE_DICOMDIR
The library must be able to parse DICOMDIR structures and the records they contain</data>
            <data key="d1">Dicomhero must be able to parse DICOMDIR structures and the records they contain.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_MEMORY_POOL_THREAD">
            <desc>There should be a memory pool per thread</desc>
            <data key="d0">REQ_MEMORY_POOL_THREAD
There should be a memory pool per thread</data>
            <data key="d1">A memory pool per thread removes the need for synchronization, increasing the
                speed of the memory pool methods.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_MEMORY_POOL_NEW_HANDLER">
            <desc>Provide a std::new_handler that clears the memory pool when necessary</desc>
            <data key="d0">REQ_MEMORY_POOL_NEW_HANDLER
Provide a std::new_handler that clears the memory pool when necessary</data>
            <data key="d1">The std::new_handler function will be automatically called when a new memory
            allocation fails, giving the memory pool an opportunity to clear the unused memory.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_APPLY_MODALITY_VOILUT">
            <desc>The library must be able to apply the modality VOI or LUT to extracted images</desc>
            <data key="d0">REQ_APPLY_MODALITY_VOILUT
The library must be able to apply the modality VOI or LUT to extracted images</data>
            <data key="d1">The library must be able to apply to the images the modality VOI or LUT specified in the dataset.
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_COMPRESS_IMAGES">
            <desc>Dicomhero must be able to compress images and insert them in the DICOM dataset</desc>
            <data key="d0">REQ_COMPRESS_IMAGES
Dicomhero must be able to compress images and insert them in the DICOM dataset</data>
            <data key="d1">Dicomhero must be able to compress images and insert them in the DICOM dataset.
                
                The recognized transfer syntaxes for the image compression are:
                
                - jpeg baseline (8 bits per color channel lossy), transfer syntax 1.2.840.10008.1.2.4.50
                - jpeg baseline extended (12 bits per color channel lossy), transfer syntax 1.2.840.10008.1.2.4.51
                - jpeg lossless (up to 16 bits per color channel lossless), transfer syntaxes 1.2.840.10008.1.2.4.57 and 1.2.840.10008.1.2.4.70
                - raw dicom (up to 16 bits per color channel lossless), transfer syntaxes 1.2.840.10008.1.2, 1.2.840.10008.1.2.1 and 1.2.840.10008.1.2.2
                - rle dicom (up to 16 bits per color channel lossless), transfer syntax 1.2.840.10008.1.2.5
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_APPLY_VOILUT">
            <desc>The library must be able to apply the presentation VOI/LUT to the extracted images</desc>
            <data key="d0">REQ_APPLY_VOILUT
The library must be able to apply the presentation VOI/LUT to the extracted images</data>
            <data key="d1">The library must be able to apply the presentation VOI/LUT to the images extracted from DICOM
                datasets
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_DONT_RETURN_POINTER">
            <desc>The API should not return pointers to allocated objects</desc>
            <data key="d0">REQ_DONT_RETURN_POINTER
The API should not return pointers to allocated objects</data>
            <data key="d1">Instead of returning pointers to the allocated objects, the library should return the object instead.
      	           Because the API allocated objects hold just pointer to the implementation classes, copying them around
      	           should not impact the performances.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_GENERIC_STREAM_PROTOCOL">
            <desc>There must be a generic streaming protocol able to transport DIMSE messages</desc>
            <data key="d0">REQ_GENERIC_STREAM_PROTOCOL
There must be a generic streaming protocol able to transport DIMSE messages</data>
            <data key="d1">There must be a generic streaming protocol able to transport DIMSE messages.

          The generic streaming protocol must derive from the Dicomhero base stream class and offer
          timeout capabilities and termination capabilities when waiting for incoming or outgoing data.
      </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_BINARY_COMPATIBILITY">
            <desc>The library should offer binary compatibility between minor revisions</desc>
            <data key="d0">REQ_BINARY_COMPATIBILITY
The library should offer binary compatibility between minor revisions</data>
            <data key="d1">The library should offer binary compatibility between minor revisions.
                
                In order to achieve this goal, minimal parts of the library interface should be exposed to the client
                application
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_OBJECT_ALLOCATION">
            <desc>Objects should be allocated via shared pointers, unique pointers or on the stack</desc>
            <data key="d0">REQ_OBJECT_ALLOCATION
Objects should be allocated via shared pointers, unique pointers or on the stack</data>
            <data key="d1">Objects shared between different components should be allocated via shared pointers,
                while objects used only once should be allocated via unique pointers or, preferably, on the stack
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_VOI_FUNCTION">
            <desc>Allow the calculation of the VOI transform using different defined DICOM functions</desc>
            <data key="d0">REQ_VOI_FUNCTION
Allow the calculation of the VOI transform using different defined DICOM functions</data>
            <data key="d1">Allow the calculation of the VOI transform using the functions LINEAR, LINEAR_EXACT and SIGMOID as defined by DICOM</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_THROW_ON_MISSING_DATA">
            <desc>The library must throw an exception when the client tries to access data that doesn't exist</desc>
            <data key="d0">REQ_THROW_ON_MISSING_DATA
The library must throw an exception when the client tries to access data that doesn't exist</data>
            <data key="d1">The library must throw an exception when the client tries to access data that doesn't exist.
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_OVERLAYS">
            <desc>The API must supply methods to retrieve and set overlay bitmaps</desc>
            <data key="d0">REQ_OVERLAYS
The API must supply methods to retrieve and set overlay bitmaps</data>
            <data key="d1">The DataSet class must supply methods to retrieve and set overlay bitmaps.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_PREPARE_RGB_IMAGE">
            <desc>Dicomhero must be able to create an image ready to be displayed on the computer screen</desc>
            <data key="d0">REQ_PREPARE_RGB_IMAGE
Dicomhero must be able to create an image ready to be displayed on the computer screen</data>
            <data key="d1">Dicomhero must be able to convert the images extracted from DICOM structures into RGBA images ready to
                be displayed into computer screens
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_DECOMPRESS_IMAGES">
            <desc>Dicomhero must be able to decompress images contained in the DICOM dataset</desc>
            <data key="d0">REQ_DECOMPRESS_IMAGES
Dicomhero must be able to decompress images contained in the DICOM dataset</data>
            <data key="d1">Dicomhero must be able to extract decompressed images from the DICOM dataset.
                The recognized transfer syntaxes for the image compression are:
                
                - jpeg baseline (8 bits per color channel lossy), transfer syntax 1.2.840.10008.1.2.4.50
                - jpeg baseline extended (12 bits per color channel lossy), transfer syntax 1.2.840.10008.1.2.4.51
                - jpeg lossless (up to 16 bits per color channel lossless), transfer syntaxes 1.2.840.10008.1.2.4.57 and 1.2.840.10008.1.2.4.70
                - raw dicom (up to 16 bits per color channel lossless), transfer syntaxes 1.2.840.10008.1.2, 1.2.840.10008.1.2.1 and 1.2.840.10008.1.2.2
                - rle dicom (up to 16 bits per color channel lossless), transfer syntax 1.2.840.10008.1.2.5
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_FUNCTIONAL_MACROS">
            <desc>The operations that get image specific parameters should be aware of Functional Macros</desc>
            <data key="d0">REQ_FUNCTIONAL_MACROS
The operations that get image specific parameters should be aware of Functional Macros</data>
            <data key="d1">Function that retrieve image related information should use also the Functional Macros (global or frame specific).
      </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_EXTRACT_LUT">
            <desc>The library must be able to extract LUT information from the DataSet</desc>
            <data key="d0">REQ_EXTRACT_LUT
The library must be able to extract LUT information from the DataSet</data>
            <data key="d1">The library must be able to extract LUT information from the dataset, regardless of the tag where
                it is stored.
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_TAGID_SEPARATE_CLASS">
            <desc>The tag id must be specified using a specific class</desc>
            <data key="d0">REQ_TAGID_SEPARATE_CLASS
The tag id must be specified using a specific class</data>
            <data key="d1">
                A class must be used to specify a Dicom tag's id (group, order, id).
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_WRITE_DICOM_FILES">
            <desc>The library must be able to write DICOM files from a DICOM structure in memory</desc>
            <data key="d0">REQ_WRITE_DICOM_FILES
The library must be able to write DICOM files from a DICOM structure in memory</data>
            <data key="d1">The library must be able to write DICOM files from a DICOM structure in memory.
                
                The following transfer syntaxes must be supported:

                - jpeg baseline (8 bits per color channel lossy), transfer syntax 1.2.840.10008.1.2.4.50
                - jpeg baseline extended (12 bits per color channel lossy), transfer syntax 1.2.840.10008.1.2.4.51
                - jpeg lossless (up to 16 bits per color channel lossless), transfer syntaxes 1.2.840.10008.1.2.4.57 and 1.2.840.10008.1.2.4.70
                - raw dicom (up to 16 bits per color channel lossless), transfer syntaxes 1.2.840.10008.1.2, 1.2.840.10008.1.2.1 and 1.2.840.10008.1.2.2
                - rle dicom (up to 16 bits per color channel lossless), transfer syntax 1.2.840.10008.1.2.5
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_ENDIANESS_PLATFORM">
            <desc>Exposed memory with raw numerical data must use the platform endianess to represent numbers</desc>
            <data key="d0">REQ_ENDIANESS_PLATFORM
Exposed memory with raw numerical data must use the platform endianess to represent numbers</data>
            <data key="d1">Numbers in the tag's memory exposed by the library must be represented using the byte endianess of
                the platform on which the library is being used.
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_THROW_WRONG_CONVERSION">
            <desc>Throw exception on non allowed VR conversions</desc>
            <data key="d0">REQ_THROW_WRONG_CONVERSION
Throw exception on non allowed VR conversions</data>
            <data key="d1">Some VR convenversions cannot be safely executed.
                In particular, the following conversions are forbidden: time and date to/from numbers, age to/from anything else.
                Failed conversion from strings to numbers must throw an exception.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_USER_PROTOCOL">
            <desc>Dicomhero must supply a base class for IO streaming</desc>
            <data key="d0">REQ_USER_PROTOCOL
Dicomhero must supply a base class for IO streaming</data>
            <data key="d1">Since Dicomhero does not provide TLS, it must provide a base IO streaming class
      	  from which the user can build its own streaming class.
      </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_READ_DICOM_FILES">
            <desc>The library must be able to read DICOM files from a data source and replicate their structure in
                memory
            </desc>
            <data key="d0">REQ_READ_DICOM_FILES
The library must be able to read DICOM files from a data source and replicate their structure in
                memory
            </data>
            <data key="d1">The library must be able to read DICOM files from a data source and replicate their structure in
                memory.
                
                The following transfer syntaxes must be supported:

                - jpeg baseline (8 bits per color channel lossy), transfer syntax 1.2.840.10008.1.2.4.50
                - jpeg baseline extended (12 bits per color channel lossy), transfer syntax 1.2.840.10008.1.2.4.51
                - jpeg lossless (up to 16 bits per color channel lossless), transfer syntaxes 1.2.840.10008.1.2.4.57 and 1.2.840.10008.1.2.4.70
                - raw dicom (up to 16 bits per color channel lossless), transfer syntaxes 1.2.840.10008.1.2, 1.2.840.10008.1.2.1 and 1.2.840.10008.1.2.2
                - rle dicom (up to 16 bits per color channel lossless), transfer syntax 1.2.840.10008.1.2.5
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_RETURN_DEFAULT_VALUE">
            <desc>There has to be a special function able to return a default value for missing tags</desc>
            <data key="d0">REQ_RETURN_DEFAULT_VALUE
There has to be a special function able to return a default value for missing tags</data>
            <data key="d1">In addition to the functions that throw an exception when the required data is missing, special
                functions able to return a default value for missing data should be present.
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_DIMSE">
            <desc>The library must be able to send and receive DIMSE messages</desc>
            <data key="d0">REQ_DIMSE
The library must be able to send and receive DIMSE messages</data>
            <data key="d1">The library must be able to build and parse DIMSE messages through an ACSE service.
                
                The following DIMSE services must be supported:

                - C-STORE
                - C-GET
                - C-MOVE
                - C-FIND
                - C-ECHO
                - C-CANCEL
                - N-EVENT-REPORT
                - N-GET
                - N-SET
                - N-ACTION
                - N-CREATE
                - N-DELETE
      </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_WRITE_TAGS">
            <desc>The library must be able to write tags into the DICOM structure</desc>
            <data key="d0">REQ_WRITE_TAGS
The library must be able to write tags into the DICOM structure</data>
            <data key="d1">The library must be able to write tags into the DICOM structure in memory.
                
                The following VRs must be supported: AE, AS, AT, CS, DA, DS, DT, FL, FD, IS, LO, LT,
                OB, OF, OD, OW, PN, SH, SL, SQ, SS, ST, TM, UI, UL, UN, US, UT, IS
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_MEMORY_POOL">
            <desc>The library should reuse unused memory instead of allocating new blocks.</desc>
            <data key="d0">REQ_MEMORY_POOL
The library should reuse unused memory instead of allocating new blocks.</data>
            <data key="d1">When a block of memory is discarded it should be stored in a memory pool
                for a while and reused when the library needs a block of the same size.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_MAKE_SHARED">
            <desc>Object inserted in shared pointers must be allocated via make_shared</desc>
            <data key="d0">REQ_MAKE_SHARED
Object inserted in shared pointers must be allocated via make_shared</data>
            <data key="d1">Object that at some point are inserted into shared pointers must be
                allocated via make_shared</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_UID_GEN">
            <desc>Supply a mechanism to generate unique DICOM UIDs</desc>
            <data key="d0">REQ_UID_GEN
Supply a mechanism to generate unique DICOM UIDs</data>
            <data key="d1">The library must be able to generate unique UIDs to be used in DICOM datasets as SOP instance UID.
      </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_NO_CALLBACK">
            <desc>User extensions should not be achievable by extending Dicomhero classes or by supplying callbacks</desc>
            <data key="d0">REQ_NO_CALLBACK
User extensions should not be achievable by extending Dicomhero classes or by supplying callbacks</data>
            <data key="d1">Allowing the user to extend Dicomhero classes or to provide callback functions complicates the separation
          between the Dicomhero's interface and its implementation.
      </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_NO_MULTIPLE_INHERITANCE">
            <desc>Multiple inheritance is not allowed</desc>
            <data key="d0">REQ_NO_MULTIPLE_INHERITANCE
Multiple inheritance is not allowed</data>
            <data key="d1">Some language for which bindings are required don't support multiple inheritance, therefore it should not be used.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_ACSE">
            <desc>The library must be able to send and receive ACSE messages through a generic transport mechanism</desc>
            <data key="d0">REQ_ACSE
The library must be able to send and receive ACSE messages through a generic transport mechanism</data>
            <data key="d1">The library must be able to send and receive DUL messages through a generic stream oriented
                transport mechanism.
                
                The ACSE management should not be exposed in the API.
      </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_READ_TAGS">
            <desc>The library must be able to extract the information contained in the DICOM tags</desc>
            <data key="d0">REQ_READ_TAGS
The library must be able to extract the information contained in the DICOM tags</data>
            <data key="d1">The library must be able to extract the tags information from the DICOM structure in memory.
                
                The following VRs must be supported: AE, AS, AT, CS, DA, DS, DT, FL, FD, IS, LO, LT,
                OB, OF, OD, OW, PN, SH, SL, SQ, SS, ST, TM, UI, UL, UN, US, UT, IS
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_RAW_MEMORY">
            <desc>The library must be able to expose the raw memory of numeric DICOM tags</desc>
            <data key="d0">REQ_RAW_MEMORY
The library must be able to expose the raw memory of numeric DICOM tags</data>
            <data key="d1">To be able to perform fast image processing, the client application needs access to the images or
                LUTs raw memory data.
                
                This implies that Dicomhero must be able to expose the raw memory used to store numeric tags (VRs: AT, FL, FD,
                OF, OW, OD, SS, SL, UL, US).
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_MEMORY_ALLOCATION">
            <desc>Memory should be allocated via cpp std arrays, vectors, strings, etc, not through new</desc>
            <data key="d0">REQ_MEMORY_ALLOCATION
Memory should be allocated via cpp std arrays, vectors, strings, etc, not through new</data>
            <data key="d1">Memory shold be allocated via c++ provided classes instantiated on the stack or
                shared pointer if they have to be shared.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_TCPIP_PROTOCOL">
            <desc>Dicomhero must supply a basic TCP streaming class</desc>
            <data key="d0">REQ_TCPIP_PROTOCOL
Dicomhero must supply a basic TCP streaming class</data>
            <data key="d1">A basic TCP streaming class must be provided so that it can be used with DUL.

          TLS is out of the scope of this class.
      </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_CPP">
            <desc>The library must be implemented in C++ 0x</desc>
            <data key="d0">REQ_CPP
The library must be implemented in C++ 0x</data>
            <data key="d1">The library must be implemented in C++0x</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_BUILD_DICOMDIR">
            <desc>The library must be able to build DICOMDIR structures and the records they contain</desc>
            <data key="d0">REQ_BUILD_DICOMDIR
The library must be able to build DICOMDIR structures and the records they contain</data>
            <data key="d1">Dicomhero must be able to build DICOMDIR structures and the records they contain.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_EXCEPTIONS">
            <desc>All the error should be reported via C++ exceptions</desc>
            <data key="d0">REQ_EXCEPTIONS
All the error should be reported via C++ exceptions</data>
            <data key="d1">The library should throw specific C++ exceptions to report errors.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_MAX_IMAGE_SIZE">
            <desc>The library must reject images that are bigger than a predefined size</desc>
            <data key="d0">REQ_MAX_IMAGE_SIZE
The library must reject images that are bigger than a predefined size</data>
            <data key="d1">The library must have a configurable setting that specifies the maximum
                size of the images that can be loaded. An exception must be thrown if the image
                is bigger than the setting allows.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_WRITING_HANDLER_EMPTY">
            <desc>New writing handler that write data to a buffer should be initially empty</desc>
            <data key="d0">REQ_WRITING_HANDLER_EMPTY
New writing handler that write data to a buffer should be initially empty</data>
            <data key="d1">For performance reasons, when a buffer returns a new writing data handler (an object
                used to write data in the tag) the writing data handler should be initially empty</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_CONST_COPY_DOCUMENTATION">
            <desc>In the documentation suggest assignments to const objects</desc>
            <data key="d0">REQ_CONST_COPY_DOCUMENTATION
In the documentation suggest assignments to const objects</data>
            <data key="d1">The returned objects should be immutable when possible. Mutable objects should be used only when they need to be modified.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_INTEGER_TYPES">
            <desc>The integer types in the public interface must be consistent</desc>
            <data key="d0">REQ_INTEGER_TYPES
The integer types in the public interface must be consistent</data>
            <data key="d1">All the integer that express a size, a file offset or an index must be of type size_t.
                All the other integers must be int32_t or uint32_t</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_DONT_EXPOSE_INDEXED_WRITING">
            <desc>Don't expose methods that allow indexed writing into the buffer while resetting it</desc>
            <data key="d0">REQ_DONT_EXPOSE_INDEXED_WRITING
Don't expose methods that allow indexed writing into the buffer while resetting it</data>
            <data key="d1">The library must not expose methods that allow indexed writing into the buffers and
            silently erase its previous content.</data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="REQ_APP_DECIDES_DEFAULT_VALUE">
            <desc>Default values must be explicitly set by the application for each tag</desc>
            <data key="d0">REQ_APP_DECIDES_DEFAULT_VALUE
Default values must be explicitly set by the application for each tag</data>
            <data key="d1">The library must not decide the default value to return when a tag is missing: the
                client application must specify the default value on each call.
            </data>
            <data key="d2">#00ff00</data>
        </node>
        <node id="RISK_RECEIVE_DEFAULT_VALUE">
            <desc>When receiving default values for non-existent data the client may understand that the tag is
                actually present
            </desc>
            <data key="d0">RISK_RECEIVE_DEFAULT_VALUE
When receiving default values for non-existent data the client may understand that the tag is
                actually present
            </data>
            <data key="d1">When receiving default values for non-existent data the client may understand that the tag is
                actually present.
            </data>
            <data key="d2">#FF0000</data>
        </node>
        <node id="RISK_VR_CONVERSION">
            <desc>Implicit VR conversion may hide wrong tag's VR</desc>
            <data key="d0">RISK_VR_CONVERSION
Implicit VR conversion may hide wrong tag's VR</data>
            <data key="d1">The library or the client may read a tag and assume its type: an implicit VR
                conversion may hide the fact that the tag has in fact the wrong VR and contain a different
                information than the assumed one.</data>
            <data key="d2">#660099</data>
        </node>
        <node id="RISK_OUT_OF_MEMORY_BIG_IMAGE">
            <desc>Big images or corrupted image size tags may cause an out-of-memory error</desc>
            <data key="d0">RISK_OUT_OF_MEMORY_BIG_IMAGE
Big images or corrupted image size tags may cause an out-of-memory error</data>
            <data key="d1">Big images or corrupted image size tags may cause an out-of-memory error</data>
            <data key="d2">#0500FA</data>
        </node>
        <node id="RISK_MEMORY_ALLOC">
            <desc>The library may use deallocated memory or forget to deallocate memory</desc>
            <data key="d0">RISK_MEMORY_ALLOC
The library may use deallocated memory or forget to deallocate memory</data>
            <data key="d1"/>
            <data key="d2">#660099</data>
        </node>
        <node id="RISK_OBJECT_ALLOC">
            <desc>The library and its client may use deallocated objects or forget to deallocate objects</desc>
            <data key="d0">RISK_OBJECT_ALLOC
The library and its client may use deallocated objects or forget to deallocate objects</data>
            <data key="d1"></data>
            <data key="d2">#660099</data>
        </node>
        <node id="RISK_WRONG_MODALITY_VOILUT_DATASET">
            <desc>The client may apply to the image the modality VOI/LUT from the wrong dataset</desc>
            <data key="d0">RISK_WRONG_MODALITY_VOILUT_DATASET
The client may apply to the image the modality VOI/LUT from the wrong dataset</data>
            <data key="d1">The client may apply to the image the modality VOI/LUT from the wrong dataset</data>
            <data key="d2">#1900E6</data>
        </node>
        <node id="RISK_TAGS_DONT_EXIST">
            <desc>The client may ask for tags that don't exist</desc>
            <data key="d0">RISK_TAGS_DONT_EXIST
The client may ask for tags that don't exist</data>
            <data key="d1">The client may ask for data not included in the dataset
            </data>
            <data key="d2">#0000FF</data>
        </node>
        <node id="RISK_SHARED_PTR_NEW">
            <desc>Out of sync shared_ptr usage counter</desc>
            <data key="d0">RISK_SHARED_PTR_NEW
Out of sync shared_ptr usage counter</data>
            <data key="d1">
                When an object is allocated with new and later inserted into a shared pointer
                then the actual object usage counter and the shared pointer usage
                counter may be out of sync.
            </data>
            <data key="d2">#1900E6</data>
        </node>
        <node id="RISK_LONG_PARAMETERS_LIST">
            <desc>
                Specifying the tag id in the dataset methods may create a long confusing list of parameters
            </desc>
            <data key="d0">RISK_LONG_PARAMETERS_LIST

                Specifying the tag id in the dataset methods may create a long confusing list of parameters
            </data>
            <data key="d1">Because the tag id is composed by group id and tag id (and optionally order id),
            the list of parameters in the methods that access a dataset's tags may become too long
            and confuse the developers that use the library.</data>
            <data key="d2">#0000FF</data>
        </node>
        <node id="RISK_BUFFER_OVERFLOW">
            <desc>The library and its client may read or write memory outside the allocated buffer</desc>
            <data key="d0">RISK_BUFFER_OVERFLOW
The library and its client may read or write memory outside the allocated buffer</data>
            <data key="d1"/>
            <data key="d2">#FF0000</data>
        </node>
        <node id="RISK_BUFFER_RESET">
            <desc>When a client wants to write several values in the buffer it may inadvertently reset the buffer</desc>
            <data key="d0">RISK_BUFFER_RESET
When a client wants to write several values in the buffer it may inadvertently reset the buffer</data>
            <data key="d1">Because a writing data handler always starts in an empty state, a client
            may inadvertently erase the buffer content when writing new content into it.</data>
            <data key="d2">#3300CC</data>
        </node>
        <node id="RISK_WRONG_VOILUT_DATASET">
            <desc>The library client may apply to an image the VOI/LUT from a wrong dataset</desc>
            <data key="d0">RISK_WRONG_VOILUT_DATASET
The library client may apply to an image the VOI/LUT from a wrong dataset</data>
            <data key="d1">The client library may apply to an image the VOILUT from the wrong dataset.
            </data>
            <data key="d2">#0700F8</data>
        </node>
        <node id="RISK_COPY_CONST_OBJECTS">
            <desc>A const object may be copied into a non-const object</desc>
            <data key="d0">RISK_COPY_CONST_OBJECTS
A const object may be copied into a non-const object</data>
            <data key="d1">Because the objects returned by the API are just handlers to implementation objects, the user
                may copy a const object into a non-const one, introducing the possibility that the implementation object
                pointed by the const object may be changed through the non-const object.</data>
            <data key="d2">#0500FA</data>
        </node>
        <node id="RISK_FULL_MEMORY">
            <desc>The memory retained in the memory pool may cause an out-of-memory error</desc>
            <data key="d0">RISK_FULL_MEMORY
The memory retained in the memory pool may cause an out-of-memory error</data>
            <data key="d1"/>
            <data key="d2">#0C00F3</data>
        </node>
        <edge source="REQ_MAX_IMAGE_SIZE" target="REQ_VARIABLE_MAX_IMAGE_SIZE"/>
        <edge source="REQ_READ_TAGS" target="REQ_VR_CONVERSION"/>
        <edge source="REQ_WRITE_TAGS" target="REQ_VR_CONVERSION"/>
        <edge source="REQ_MEMORY_POOL" target="REQ_MEMORY_POOL_THREAD"/>
        <edge source="RISK_FULL_MEMORY" target="REQ_MEMORY_POOL_NEW_HANDLER"/>
        <edge source="REQ_DIMSE" target="REQ_GENERIC_STREAM_PROTOCOL"/>
        <edge source="RISK_OBJECT_ALLOC" target="REQ_OBJECT_ALLOCATION"/>
        <edge source="RISK_TAGS_DONT_EXIST" target="REQ_THROW_ON_MISSING_DATA"/>
        <edge source="RISK_LONG_PARAMETERS_LIST" target="REQ_TAGID_SEPARATE_CLASS"/>
        <edge source="RISK_VR_CONVERSION" target="REQ_THROW_WRONG_CONVERSION"/>
        <edge source="REQ_TCPIP_PROTOCOL" target="REQ_USER_PROTOCOL"/>
        <edge source="REQ_READ_TAGS" target="REQ_RETURN_DEFAULT_VALUE"/>
        <edge source="RISK_SHARED_PTR_NEW" target="REQ_MAKE_SHARED"/>
        <edge source="REQ_USER_PROTOCOL" target="REQ_NO_CALLBACK"/>
        <edge source="RISK_MEMORY_ALLOC" target="REQ_MEMORY_ALLOCATION"/>
        <edge source="REQ_DIMSE" target="REQ_TCPIP_PROTOCOL"/>
        <edge source="RISK_OUT_OF_MEMORY_BIG_IMAGE" target="REQ_MAX_IMAGE_SIZE"/>
        <edge source="RISK_COPY_CONST_OBJECTS" target="REQ_CONST_COPY_DOCUMENTATION"/>
        <edge source="RISK_BUFFER_RESET" target="REQ_DONT_EXPOSE_INDEXED_WRITING"/>
        <edge source="RISK_RECEIVE_DEFAULT_VALUE" target="REQ_APP_DECIDES_DEFAULT_VALUE"/>
        <edge source="REQ_RETURN_DEFAULT_VALUE" target="RISK_RECEIVE_DEFAULT_VALUE"/>
        <edge source="REQ_VR_CONVERSION" target="RISK_VR_CONVERSION"/>
        <edge source="REQ_DECOMPRESS_IMAGES" target="RISK_OUT_OF_MEMORY_BIG_IMAGE"/>
        <edge source="REQ_CPP" target="RISK_MEMORY_ALLOC"/>
        <edge source="REQ_CPP" target="RISK_OBJECT_ALLOC"/>
        <edge source="REQ_APPLY_MODALITY_VOILUT" target="RISK_WRONG_MODALITY_VOILUT_DATASET"/>
        <edge source="REQ_READ_TAGS" target="RISK_TAGS_DONT_EXIST"/>
        <edge source="REQ_OBJECT_ALLOCATION" target="RISK_SHARED_PTR_NEW"/>
        <edge source="REQ_CPP" target="RISK_BUFFER_OVERFLOW"/>
        <edge source="REQ_RAW_MEMORY" target="RISK_BUFFER_OVERFLOW"/>
        <edge source="REQ_WRITING_HANDLER_EMPTY" target="RISK_BUFFER_RESET"/>
        <edge source="REQ_APPLY_VOILUT" target="RISK_WRONG_VOILUT_DATASET"/>
        <edge source="REQ_DONT_RETURN_POINTER" target="RISK_COPY_CONST_OBJECTS"/>
        <edge source="REQ_MEMORY_POOL" target="RISK_FULL_MEMORY"/>
    </graph>
</graphml>
