buildscript {

    ext.kotlin_version = '1.6.10'


    /**
     * The repositories block configures the repositories Gradle uses to
     * search or download the dependencies. Gradle pre-configures support for remote
     * repositories such as JCenter, Maven Central, and Ivy. You can also use local
     * repositories or define your own remote repositories. The code below defines
     * JCenter as the repository Gradle should use to look for its dependencies.
     *
     * New projects created using Android Studio 3.0 and higher also include
     * Google's Maven repository.
     */

    repositories {
        google()
        mavenCentral()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:7.1.2'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }

}

apply plugin: 'com.android.library'

dependencies {
    androidTestImplementation 'androidx.annotation:annotation:1.0.0'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test:rules:1.1.1'
}

def generatedDir = new File("${buildDir}/generated")
def jniSourceDir = new File("${generatedDir}/src")
def jniComDir = new File("${jniSourceDir}/com")
def jniDicomHeroDir = new File("${jniComDir}/dicomhero")
def jniWrapperDir = new File("${jniDicomHeroDir}/api")
def jniCppDir = new File("${generatedDir}/jni")
def jniCppFile = new File("${jniCppDir}/dicomhero_jni.cpp")
def swigFile = new File("${projectDir}/dicomheroCore6/wrappers/swig/swig.i")
def Properties properties = new Properties()
properties.load(project.rootProject.file("local.properties").newDataInputStream())


android {
    repositories {
        mavenCentral()
        google()
    }
    ndkVersion "24.0.8215888"

    defaultConfig {
        minSdkVersion 28
        compileSdkVersion 34
        targetSdkVersion 33
        testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'

        versionName getVersionString()
        versionCode calculateVersionCode()

        externalNativeBuild{
            cmake {
                targets "dicomhero6"
                arguments "-DDICOMHERO_JNI_FILE=${jniCppFile.absolutePath}",
                        "-DDICOMHERO_CHARSET_CONVERSION=JAVA"
            }
        }

    }

    externalNativeBuild{
        cmake {
            path "${projectDir}/CMakeLists.txt"
        }
    }

    sourceSets {
        main {
            manifest.srcFile 'AndroidManifest.xml'
            java {
                srcDir 'src'
                srcDir "${jniSourceDir}"
            }
        }
    }

    libraryVariants.all { variant ->
        variant.outputs.all { output ->
            if (outputFile != null && outputFileName.endsWith('.aar')) {
                outputFileName = "dicomhero6-${variant.buildType.name}-" + getVersionString() + ".aar"
            }
        }
    }

    buildTypes {
        release {
            debuggable false
        }
    }

    android.buildTypes.release.ndk.debugSymbolLevel = "full"
    android.buildTypes.debug.ndk.debugSymbolLevel = "full"

}

repositories {
    google()
    mavenCentral()
}

def getVersionString(){
    def out = new ByteArrayOutputStream();
    def activeBranch = ''
    try
    {
        exec {
            executable = 'git'
            args = ['branch']
            standardOutput = out
        }
        String[] branches = out.toString().split("(\\r\\n|\\r|\\n)")
        for(branch in branches)
        {
            if(branch.startsWith('* '))
            {
                activeBranch = branch.substring(2)
                break
            }
        }

        def appVeyorBranch = System.getenv('APPVEYOR_REPO_BRANCH')
        if(appVeyorBranch != null && !appVeyorBranch.isEmpty())
        {
            activeBranch = appVeyorBranch
        }
        println("branch " + activeBranch)

        if(activeBranch ==~ '^(\\d+)(\\.\\d+)*$' || activeBranch ==~ '.*/(\\d+)(\\.\\d+)*$')
        {
            def versionParts = (activeBranch + '.0.0.0') =~ /[0-9]+/
            def version = versionParts[0] + "." + versionParts[1] + "." + versionParts[2]
            println("version " + version)
            return version
        }
        println("version 0.0.1")
        return '0.0.1'
    }
    catch (Exception e)
    {
        File versionFile = new File("dicomheroCore6/library/include/versionBuild.txt");
        def versionParts = (versionFile.getText() + ".0.0.0") =~ /[0-9]+/
        def version = versionParts[0] + "." + versionParts[1] + "." + versionParts[2]
        println("version " + version)
        return version
    }
}


def calculateVersionCode(){
    def version = getVersionString()
    String[] versionParts = version.split('\\.')
    def versionCode = (versionParts[0] as int) * 1024 * 1024 + (versionParts[1] as int) * 1024 + (versionParts[2] as int)
    println("version code " + versionCode.toString())
    return versionCode
}


task createCoreWrapperDir {
    jniWrapperDir.mkdirs()
}

task runSwig(type:Exec, dependsOn: ['createCoreWrapperDir']) {
    mkdir(generatedDir.absolutePath)
    mkdir(jniSourceDir.absolutePath)
    mkdir(jniComDir.absolutePath)
    mkdir(jniDicomHeroDir.absolutePath)
    mkdir(jniWrapperDir.absolutePath)
    mkdir(jniCppDir.absolutePath)
    inputs.file("${swigFile}")
    println "${jniCppFile}"
    commandLine 'swig',
            '-c++',
            '-java',
            '-package', 'com.dicomhero.api',
            '-outdir', jniWrapperDir.absolutePath,
            '-o', jniCppFile.absolutePath,
            swigFile.absolutePath
}

preBuild.dependsOn runSwig
